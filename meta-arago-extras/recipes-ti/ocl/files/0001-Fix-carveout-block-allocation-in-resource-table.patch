ocl: Fix carveout block allocation in resource table

Upstream-Status: Submitted

- Carveout blocks in the resource table could be allocated in two different
  ways.  One is CMA (with reserved memory marked as "reusable"), which will
  use 1MB alignment.  The other is DMA pool (with reserved memory marked as
  "no-map"), which will round up block size and alignment to power of 2.
  In DMA pool case, if not careful, carveout blocks could end up not able
  to be allocated in the available memory, while CMA succeeds.
- This commit addresses the possibe carveout block allocation failure
  in DMA pool case. In particular,
  - AM57 DSP: 6MB carveout block is split into 4MB and 2MB.
    - Without this fix, DMA pool allocation actually will fail on DSP2
      due to its smaller 8MB reserved memory, with its first 1MB being
      allocated to VRING/IPC.
  - AM57 IPU1: slight carveout block size adjustment.
    - Take this opportunity to make code/data blocks tighter, so that
      unused memory can be returned to Linux in "reusable" allocation.
- MCT-1225, LCPD-17021, LCPD-17331

Signed-off-by: Yuan Zhao <yuanzhao@ti.com>
---
 monitor/cmds/monitor.am57x.cmd                |  8 ++---
 monitor/platforms/am57x/Platform.xdc          | 14 +++++---
 monitor/src/custom_rsc_table_vayu_dsp.h       | 32 +++++++++++++++----
 .../cfg/mem_segment_definition_linux.xs       |  8 ++---
 4 files changed, 43 insertions(+), 19 deletions(-)

diff --git a/monitor/cmds/monitor.am57x.cmd b/monitor/cmds/monitor.am57x.cmd
index 298a5d1..f41f1a8 100644
--- a/monitor/cmds/monitor.am57x.cmd
+++ b/monitor/cmds/monitor.am57x.cmd
@@ -181,11 +181,11 @@ SECTIONS
                 "nullres.ae66"      (.fardata)
                 "nullres.ae66"      (.far)
     } > L2SRAM
-    .localddr: load >> DDR3
-    .ctools_core_private: load >> DDR3
+    .localddr: load >> DDR3_FC
+    .ctools_core_private: load >> DDR3_FC
 
-    .fardata: load >> DDR3
-    .far: load >> DDR3
+    .fardata: load >> DDR3_FC
+    .far: load >> DDR3_FC
     .gdb_server: load = L2SRAM, type = NOLOAD, fill = 0x0
 }
 
diff --git a/monitor/platforms/am57x/Platform.xdc b/monitor/platforms/am57x/Platform.xdc
index e2b4c33..e77129f 100644
--- a/monitor/platforms/am57x/Platform.xdc
+++ b/monitor/platforms/am57x/Platform.xdc
@@ -36,20 +36,24 @@ config ti.platforms.generic.Platform.Instance CPU =
 
       /*-----------------------------------------------------------------------
       * DDR Related regions
+      * all text in DDR3, data in DDR3 and DDR3_FC
+      * Remoteproc Carveout memory block are allocated at 1MB boundary by
+      * CMA allocator, however, by power of 2 size and boundary by DMA pool
+      * allocator.  Hence, making blocks of power of 2 sizes to reduce gaps
       *----------------------------------------------------------------------*/
       [ "DDR3",         { name: "DDR3", 
                           base: 0xFEB00000,
-			              len:  0x004f3000,
+                          len:  0x00400000,
                           space: "code/data", 
-			              access: "RWX", } ],
+                          access: "RWX", } ],
 
       /* Each DSP core uses its own framework components data structure
          via remoteproc memory allocation for carveout */
       [ "DDR3_FC",     { name: "DDR3_FC",
-                         base: 0xFEFF3000,
-			             len:  0x0000D000,
+                         base: 0xFEF00000,
+                         len:  0x00100000,
                          space: "code/data",
-			             access: "RWX", } ],
+                         access: "RWX", } ],
 
 
       /* DDR3_NC, DDR3_STACK and DDR3_HEAP placed in the first 32MB of
diff --git a/monitor/src/custom_rsc_table_vayu_dsp.h b/monitor/src/custom_rsc_table_vayu_dsp.h
index 898026c..4752bea 100644
--- a/monitor/src/custom_rsc_table_vayu_dsp.h
+++ b/monitor/src/custom_rsc_table_vayu_dsp.h
@@ -115,6 +115,19 @@
 // DDR3, DDR3_FC and SR_0 regions in platforms/am57/Platform.xdc
 #define DSP_MEM_DDR             0xFEB00000
 #define DSP_MEM_DDR_SIZE        (SZ_1M * 6)
+/*
+ * To avoid issues with allocation failures with Linux carveout regions, need
+ * to use the RSC_CARVEOUT entries with power of 2 page order sizes and aligned
+ * on the same page order.
+ * The size and the alignment order of entries in the resource table plays a
+ * part in avoiding gaps in allocation
+ */
+#define DSP_MEM_DDR0            0xFEB00000
+#define DSP_MEM_DDR0_SIZE       (SZ_1M * 4)
+#define DSP_MEM_DDR1            0xFEF00000
+#define DSP_MEM_DDR1_SIZE       (SZ_1M * 2)
+
+
 
 // CMEM buffers mapped by MMU to PHYS_MEM_IOBUFS
 // If DSP_MEM_IOBUFS is modified, corresponding changes must be made
@@ -157,7 +170,7 @@
 struct my_resource_table {
     struct resource_table base;
 
-    UInt32 offset[20];  /* Should match 'num' in actual definition */
+    UInt32 offset[21];  /* Should match 'num' in actual definition */
 
     /* rpmsg vdev entry */
     struct fw_rsc_vdev rpmsg_vdev;
@@ -165,7 +178,8 @@ struct my_resource_table {
     struct fw_rsc_vdev_vring rpmsg_vring1;
 
     /* text carveout entry */
-    struct fw_rsc_carveout ddr_cout;
+    struct fw_rsc_carveout ddr0_cout;
+    struct fw_rsc_carveout ddr1_cout;
 
     /* trace entry */
     struct fw_rsc_trace trace;
@@ -224,12 +238,13 @@ extern char ti_trace_SysMin_Module_State_0_outbuf__A;
 
 struct my_resource_table ti_ipc_remoteproc_ResourceTable = {
     1,      /* we're the first version that implements this */
-    20,     /* number of entries in the table */
+    21,     /* number of entries in the table */
     0, 0,   /* reserved, must be zero */
     /* offsets to entries */
     {
         offsetof(struct my_resource_table, rpmsg_vdev),
-        offsetof(struct my_resource_table, ddr_cout),
+        offsetof(struct my_resource_table, ddr0_cout),
+        offsetof(struct my_resource_table, ddr1_cout),
         offsetof(struct my_resource_table, trace),
         offsetof(struct my_resource_table, devmem0),
         offsetof(struct my_resource_table, devmem1),
@@ -262,8 +277,13 @@ struct my_resource_table ti_ipc_remoteproc_ResourceTable = {
 
     {
         TYPE_CARVEOUT,
-        DSP_MEM_DDR, 0,
-        DSP_MEM_DDR_SIZE, 0, 0, "DSP_MEM_DDR",
+        DSP_MEM_DDR0, 0,
+        DSP_MEM_DDR0_SIZE, 0, 0, "DSP_MEM_DDR0",
+    },
+    {
+        TYPE_CARVEOUT,
+        DSP_MEM_DDR1, 0,
+        DSP_MEM_DDR1_SIZE, 0, 0, "DSP_MEM_DDR1",
     },
 
     {
diff --git a/monitor_ipu/cfg/mem_segment_definition_linux.xs b/monitor_ipu/cfg/mem_segment_definition_linux.xs
index bcaad52..a76b749 100644
--- a/monitor_ipu/cfg/mem_segment_definition_linux.xs
+++ b/monitor_ipu/cfg/mem_segment_definition_linux.xs
@@ -112,11 +112,11 @@ EVE4_SRAM_SIZE              = 1*MB;
 
 /* Allocating virtual addresses for carveouts */
 /* IPU1 code, data, heap,  IPC data: trace buf, exc data, pm data */
-IPU1_CODE_SIZE              = 5*MB;
-IPU1_DATA_SIZE              = 4*MB;
-IPU1_HEAP_SIZE              = 11*MB;
+IPU1_CODE_SIZE              = 1*MB;
+IPU1_DATA_SIZE              = 2*MB;
+IPU1_HEAP_SIZE              = 10*MB;
 
-IPU1_CODE_ADDR              = 0x9D100000;
+IPU1_CODE_ADDR              = 0x9D300000;
 IPU1_DATA_ADDR              = IPU1_CODE_ADDR + IPU1_CODE_SIZE;
 IPU1_HEAP_ADDR              = IPU1_DATA_ADDR + IPU1_DATA_SIZE;
 
-- 
2.17.1

